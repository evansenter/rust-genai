name: CI Flakiness Report

on:
  schedule:
    - cron: '0 9 * * *'  # Daily at 9am UTC
  workflow_dispatch:  # Allow manual triggering

permissions:
  contents: read
  issues: write
  actions: read  # Required for artifact access

jobs:
  flakiness-report:
    name: Generate Flakiness Report
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Collect and categorize failures
        id: collect
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Configuration
          DAYS_BACK=7
          WORKFLOW_NAME="Rust"

          # Calculate date range
          END_DATE=$(date -u +"%Y-%m-%d")
          START_DATE=$(date -u -d "$DAYS_BACK days ago" +"%Y-%m-%d")

          echo "Analyzing CI runs from $START_DATE to $END_DATE"
          echo "start_date=$START_DATE" >> $GITHUB_OUTPUT
          echo "end_date=$END_DATE" >> $GITHUB_OUTPUT

          # Initialize counters
          TOTAL_RUNS=0
          FAILED_RUNS=0
          declare -A TEST_FAILURES
          declare -A TEST_FILES
          declare -A TEST_CATEGORIES

          # Category totals
          API_ERRORS=0
          RATE_LIMIT=0
          ASSERTION_FAILURES=0
          PANIC=0
          UNKNOWN=0

          # Get all workflow runs from the past week
          echo "Fetching workflow runs..."
          RUNS_JSON=$(gh run list \
            --workflow "$WORKFLOW_NAME" \
            --limit 200 \
            --json databaseId,conclusion,createdAt,headBranch,event \
            2>/dev/null || echo "[]")

          # Filter runs from the past week
          WEEK_AGO=$(date -u -d "$DAYS_BACK days ago" +%s)

          # Process runs
          while IFS= read -r run; do
            RUN_ID=$(echo "$run" | jq -r '.databaseId')
            CONCLUSION=$(echo "$run" | jq -r '.conclusion')
            CREATED_AT=$(echo "$run" | jq -r '.createdAt')

            # Convert to timestamp and check if within range
            RUN_TS=$(date -d "$CREATED_AT" +%s 2>/dev/null || echo "0")
            if [ "$RUN_TS" -lt "$WEEK_AGO" ]; then
              continue
            fi

            TOTAL_RUNS=$((TOTAL_RUNS + 1))

            if [ "$CONCLUSION" = "failure" ]; then
              FAILED_RUNS=$((FAILED_RUNS + 1))

              echo "Analyzing failed run $RUN_ID..."

              # Categorize failures using the script
              CATEGORIZED=$(.github/scripts/categorize_failures.sh "$RUN_ID" 2>/dev/null || echo '{"totals":{}}')

              # Accumulate category totals
              API_ERRORS=$((API_ERRORS + $(echo "$CATEGORIZED" | jq -r '.totals.api_errors // 0')))
              RATE_LIMIT=$((RATE_LIMIT + $(echo "$CATEGORIZED" | jq -r '.totals.rate_limit // 0')))
              ASSERTION_FAILURES=$((ASSERTION_FAILURES + $(echo "$CATEGORIZED" | jq -r '.totals.assertion_failures // 0')))
              PANIC=$((PANIC + $(echo "$CATEGORIZED" | jq -r '.totals.panic // 0')))
              UNKNOWN=$((UNKNOWN + $(echo "$CATEGORIZED" | jq -r '.totals.unknown // 0')))

              # Extract test names with categories
              for category in api_errors rate_limit assertion_failures panic unknown; do
                while IFS= read -r test_name; do
                  if [ -n "$test_name" ] && [ "$test_name" != "null" ]; then
                    if [ -n "${TEST_FAILURES[$test_name]:-}" ]; then
                      TEST_FAILURES[$test_name]=$((TEST_FAILURES[$test_name] + 1))
                    else
                      TEST_FAILURES[$test_name]=1
                      TEST_CATEGORIES[$test_name]="$category"
                    fi
                  fi
                done < <(echo "$CATEGORIZED" | jq -r ".categories.$category[]?" 2>/dev/null || true)
              done
            fi
          done < <(echo "$RUNS_JSON" | jq -c '.[]')

          # Count unique flaky tests
          UNIQUE_FLAKY=${#TEST_FAILURES[@]}

          echo "total_runs=$TOTAL_RUNS" >> $GITHUB_OUTPUT
          echo "failed_runs=$FAILED_RUNS" >> $GITHUB_OUTPUT
          echo "unique_flaky=$UNIQUE_FLAKY" >> $GITHUB_OUTPUT
          echo "api_errors=$API_ERRORS" >> $GITHUB_OUTPUT
          echo "rate_limit=$RATE_LIMIT" >> $GITHUB_OUTPUT
          echo "assertion_failures=$ASSERTION_FAILURES" >> $GITHUB_OUTPUT
          echo "panic=$PANIC" >> $GITHUB_OUTPUT

          # Find test file locations
          echo "Locating test files..."
          for test_name in "${!TEST_FAILURES[@]}"; do
            FILE=$(grep -rlE "fn $test_name|fn ${test_name#*::}" tests/ src/ 2>/dev/null | head -1 || echo "unknown")
            if [ -n "$FILE" ] && [ "$FILE" != "unknown" ]; then
              TEST_FILES[$test_name]=$(basename "$FILE")
            else
              TEST_FILES[$test_name]="unknown"
            fi
          done

          # Write summary JSON for artifact (using jq for safe construction)
          jq -n \
            --argjson total_runs "$TOTAL_RUNS" \
            --argjson failed_runs "$FAILED_RUNS" \
            --argjson unique_flaky "$UNIQUE_FLAKY" \
            --argjson api_errors "$API_ERRORS" \
            --argjson rate_limit "$RATE_LIMIT" \
            --argjson assertion_failures "$ASSERTION_FAILURES" \
            --argjson panic "$PANIC" \
            --argjson unknown "$UNKNOWN" \
            --arg date "$END_DATE" \
            '{
              total_runs: $total_runs,
              failed_runs: $failed_runs,
              unique_flaky: $unique_flaky,
              api_errors: $api_errors,
              rate_limit: $rate_limit,
              assertion_failures: $assertion_failures,
              panic: $panic,
              unknown: $unknown,
              date: $date
            }' > summary.json

          # Write tests JSON for report generation (using jq for safe construction)
          echo "[]" > tests.json
          for test_name in "${!TEST_FAILURES[@]}"; do
            jq -n \
              --arg name "$test_name" \
              --argjson failures "${TEST_FAILURES[$test_name]}" \
              --arg category "${TEST_CATEGORIES[$test_name]:-unknown}" \
              --arg file "${TEST_FILES[$test_name]:-unknown}" \
              '{name: $name, failures: $failures, category: $category, file: $file}' \
              | jq -s '.[0] as $new | input + [$new]' tests.json - > tests.json.tmp \
              && mv tests.json.tmp tests.json
          done

      - name: Compare trends
        id: trends
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          .github/scripts/compare_trends.sh "flakiness-summary" summary.json > trends.json

      - name: Generate report
        id: report
        run: |
          .github/scripts/generate_flakiness_report.sh \
            --trends trends.json \
            --tests tests.json \
            --start-date "${{ steps.collect.outputs.start_date }}" \
            --end-date "${{ steps.collect.outputs.end_date }}" \
            --repo-url "${{ github.server_url }}/${{ github.repository }}" \
            > flakiness_report.md

          echo "=== Report Content ==="
          cat flakiness_report.md
          echo "======================"

      - name: Upload summary artifact
        uses: actions/upload-artifact@v4
        with:
          name: flakiness-summary-${{ steps.collect.outputs.end_date }}
          path: summary.json
          retention-days: 14

      - name: Create or update issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          TITLE="CI Flakiness Report - Week of $(date -u +"%Y-%m-%d")"

          # Check if an issue with ci-health label already exists for this week
          EXISTING_ISSUE=$(gh issue list \
            --label "ci-health" \
            --state open \
            --json number,title \
            --jq ".[] | select(.title | startswith(\"CI Flakiness Report - Week of $(date -u +\"%Y-%m-%d\")\")) | .number" \
            2>/dev/null || echo "")

          if [ -n "$EXISTING_ISSUE" ]; then
            echo "Updating existing issue #$EXISTING_ISSUE"
            gh issue edit "$EXISTING_ISSUE" --body-file "flakiness_report.md"
            echo "Updated issue: ${{ github.server_url }}/${{ github.repository }}/issues/$EXISTING_ISSUE"
          else
            echo "Creating new issue"
            # First ensure the ci-health label exists
            gh label create "ci-health" \
              --description "CI health and flakiness tracking" \
              --color "fbca04" \
              2>/dev/null || true

            NEW_ISSUE=$(gh issue create \
              --title "$TITLE" \
              --body-file "flakiness_report.md" \
              --label "ci-health")
            echo "Created issue: $NEW_ISSUE"
          fi
