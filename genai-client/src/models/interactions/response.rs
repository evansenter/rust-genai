//! Response types for the Interactions API.
//!
//! This module contains `InteractionResponse` and related types for handling
//! API responses, including helper methods for extracting content.

use serde::{Deserialize, Serialize};
use std::collections::BTreeSet;
use std::fmt;

use super::content::{CodeExecutionLanguage, CodeExecutionOutcome, InteractionContent};
use super::metadata::{GroundingMetadata, UrlContextMetadata};
use crate::models::shared::Tool;

/// Status of an interaction.
///
/// This enum is marked `#[non_exhaustive]` for forward compatibility.
/// New status values may be added by the API in future versions.
///
/// # Unknown Status Handling
///
/// When the API returns a status value that this library doesn't recognize,
/// it will be captured in the `Unknown` variant with the original status
/// string preserved. This follows the Evergreen philosophy of graceful
/// degradation and data preservation.
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InteractionStatus {
    Completed,
    InProgress,
    RequiresAction,
    Failed,
    Cancelled,
    /// Unknown status (for forward compatibility).
    ///
    /// This variant captures any unrecognized status values from the API,
    /// allowing the library to handle new statuses gracefully.
    ///
    /// The `status_type` field contains the unrecognized status string,
    /// and `data` contains the JSON value (typically the same string).
    Unknown {
        /// The unrecognized status string from the API
        status_type: String,
        /// The raw JSON value, preserved for debugging
        data: serde_json::Value,
    },
}

impl InteractionStatus {
    /// Check if this is an unknown status.
    #[must_use]
    pub const fn is_unknown(&self) -> bool {
        matches!(self, Self::Unknown { .. })
    }

    /// Returns the status type name if this is an unknown status.
    ///
    /// Returns `None` for known statuses.
    #[must_use]
    pub fn unknown_status_type(&self) -> Option<&str> {
        match self {
            Self::Unknown { status_type, .. } => Some(status_type),
            _ => None,
        }
    }

    /// Returns the raw JSON data if this is an unknown status.
    ///
    /// Returns `None` for known statuses.
    #[must_use]
    pub fn unknown_data(&self) -> Option<&serde_json::Value> {
        match self {
            Self::Unknown { data, .. } => Some(data),
            _ => None,
        }
    }
}

impl Serialize for InteractionStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Completed => serializer.serialize_str("completed"),
            Self::InProgress => serializer.serialize_str("in_progress"),
            Self::RequiresAction => serializer.serialize_str("requires_action"),
            Self::Failed => serializer.serialize_str("failed"),
            Self::Cancelled => serializer.serialize_str("cancelled"),
            Self::Unknown { status_type, .. } => serializer.serialize_str(status_type),
        }
    }
}

impl<'de> Deserialize<'de> for InteractionStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let value = serde_json::Value::deserialize(deserializer)?;

        match value.as_str() {
            Some("completed") => Ok(Self::Completed),
            Some("in_progress") => Ok(Self::InProgress),
            Some("requires_action") => Ok(Self::RequiresAction),
            Some("failed") => Ok(Self::Failed),
            Some("cancelled") => Ok(Self::Cancelled),
            Some(other) => {
                log::warn!(
                    "Encountered unknown InteractionStatus '{}'. \
                     This may indicate a new API feature. \
                     The status will be preserved in the Unknown variant.",
                    other
                );
                Ok(Self::Unknown {
                    status_type: other.to_string(),
                    data: value,
                })
            }
            None => {
                // Non-string value - preserve it in Unknown
                let status_type = format!("<non-string: {}>", value);
                log::warn!(
                    "InteractionStatus received non-string value: {}. \
                     Preserving in Unknown variant.",
                    value
                );
                Ok(Self::Unknown {
                    status_type,
                    data: value,
                })
            }
        }
    }
}

/// Token usage information from the Interactions API
#[derive(Clone, Deserialize, Serialize, Debug, Default, PartialEq)]
#[serde(default)]
pub struct UsageMetadata {
    /// Total number of input tokens (prompt tokens sent to the model)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_input_tokens: Option<i32>,
    /// Total number of output tokens (tokens generated by the model)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_output_tokens: Option<i32>,
    /// Total number of tokens (input + output)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_tokens: Option<i32>,
    /// Total number of cached tokens (from context caching, reduces billing)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_cached_tokens: Option<i32>,
    /// Total number of reasoning tokens (populated for thinking models like gemini-2.0-flash-thinking)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_reasoning_tokens: Option<i32>,
    /// Total number of tokens used for tool/function calling overhead
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_tool_use_tokens: Option<i32>,
}

impl UsageMetadata {
    /// Returns true if any usage data is present
    #[must_use]
    pub fn has_data(&self) -> bool {
        self.total_tokens.is_some()
            || self.total_input_tokens.is_some()
            || self.total_output_tokens.is_some()
            || self.total_cached_tokens.is_some()
            || self.total_reasoning_tokens.is_some()
            || self.total_tool_use_tokens.is_some()
    }
}

/// Information about a function call requested by the model.
///
/// Returned by [`InteractionResponse::function_calls()`] for convenient access
/// to function call details.
///
/// This is a **view type** that borrows data from the underlying [`InteractionResponse`].
/// It implements [`Serialize`] for logging and debugging purposes, but not `Deserialize`
/// since it's not meant to be constructed directly—use the response helper methods instead.
///
/// # Example
///
/// ```no_run
/// # use genai_client::models::interactions::InteractionResponse;
/// # let response: InteractionResponse = todo!();
/// for call in response.function_calls() {
///     println!("Function: {} with args: {}", call.name, call.args);
///     if let Some(id) = call.id {
///         println!("  Call ID: {}", id);
///     }
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Serialize)]
pub struct FunctionCallInfo<'a> {
    /// Unique identifier for this function call (used when sending results back)
    pub id: Option<&'a str>,
    /// Name of the function to call
    pub name: &'a str,
    /// Arguments to pass to the function
    pub args: &'a serde_json::Value,
    /// Thought signature for Gemini 3 reasoning continuity
    pub thought_signature: Option<&'a str>,
}

impl FunctionCallInfo<'_> {
    /// Convert to an owned version that doesn't borrow from the response.
    ///
    /// Use this when you need to store function call data beyond the lifetime
    /// of the response, such as for event emission, trajectory recording,
    /// or passing to async tasks.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// // Store function calls for later processing
    /// let owned_calls: Vec<_> = response.function_calls()
    ///     .into_iter()
    ///     .map(|call| call.to_owned())
    ///     .collect();
    /// ```
    #[must_use]
    pub fn to_owned(&self) -> OwnedFunctionCallInfo {
        OwnedFunctionCallInfo {
            id: self.id.map(String::from),
            name: self.name.to_string(),
            args: self.args.clone(),
            thought_signature: self.thought_signature.map(String::from),
        }
    }
}

/// Owned version of [`FunctionCallInfo`] for storing beyond response lifetime.
///
/// This type owns all its data, making it suitable for:
/// - Event emission with function call metadata
/// - Trajectory/replay recording
/// - Passing to async tasks or storing in collections
///
/// # Example
///
/// ```no_run
/// # use genai_client::models::interactions::InteractionResponse;
/// # let response: InteractionResponse = todo!();
/// let owned_calls: Vec<_> = response.function_calls()
///     .into_iter()
///     .map(|call| call.to_owned())
///     .collect();
///
/// // owned_calls can now outlive `response`
/// for call in owned_calls {
///     println!("Function: {} with args: {}", call.name, call.args);
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct OwnedFunctionCallInfo {
    /// Unique identifier for this function call (used when sending results back)
    pub id: Option<String>,
    /// Name of the function to call
    pub name: String,
    /// Arguments to pass to the function
    pub args: serde_json::Value,
    /// Thought signature for Gemini 3 reasoning continuity
    pub thought_signature: Option<String>,
}

/// Information about a function result in the response.
///
/// Returned by [`InteractionResponse::function_results()`] for convenient access
/// to function result details.
///
/// This is a **view type** that borrows data from the underlying [`InteractionResponse`].
/// It implements [`Serialize`] for logging and debugging purposes, but not `Deserialize`
/// since it's not meant to be constructed directly—use the response helper methods instead.
///
/// # Example
///
/// ```no_run
/// # use genai_client::models::interactions::InteractionResponse;
/// # let response: InteractionResponse = todo!();
/// for result in response.function_results() {
///     println!("Function {} returned: {}", result.name, result.result);
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Serialize)]
pub struct FunctionResultInfo<'a> {
    /// Name of the function that was called
    pub name: &'a str,
    /// The call_id from the FunctionCall this result responds to
    pub call_id: &'a str,
    /// The result returned by the function
    pub result: &'a serde_json::Value,
}

/// Information about a code execution call requested by the model.
///
/// Returned by [`InteractionResponse::code_execution_calls()`] for convenient access
/// to code execution details.
///
/// This is a **view type** that borrows data from the underlying [`InteractionResponse`].
/// It implements [`Serialize`] for logging and debugging purposes, but not `Deserialize`
/// since it's not meant to be constructed directly—use the response helper methods instead.
///
/// # Example
///
/// ```no_run
/// # use genai_client::models::interactions::InteractionResponse;
/// # let response: InteractionResponse = todo!();
/// for call in response.code_execution_calls() {
///     println!("Executing {} code (id: {})", call.language, call.id);
///     println!("Code: {}", call.code);
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Serialize)]
#[non_exhaustive]
pub struct CodeExecutionCallInfo<'a> {
    /// Unique identifier for this code execution call
    pub id: &'a str,
    /// Programming language (currently only Python is supported)
    pub language: CodeExecutionLanguage,
    /// Source code to execute
    pub code: &'a str,
}

/// Information about a code execution result.
///
/// Returned by [`InteractionResponse::code_execution_results()`] for convenient access
/// to code execution results.
///
/// This is a **view type** that borrows data from the underlying [`InteractionResponse`].
/// It implements [`Serialize`] for logging and debugging purposes, but not `Deserialize`
/// since it's not meant to be constructed directly—use the response helper methods instead.
///
/// # Example
///
/// ```no_run
/// # use genai_client::models::interactions::InteractionResponse;
/// # let response: InteractionResponse = todo!();
/// for result in response.code_execution_results() {
///     println!("Call {} completed with outcome: {}", result.call_id, result.outcome);
///     if result.outcome.is_success() {
///         println!("Output: {}", result.output);
///     }
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Serialize)]
#[non_exhaustive]
pub struct CodeExecutionResultInfo<'a> {
    /// The call_id matching the CodeExecutionCall this result is for
    pub call_id: &'a str,
    /// Execution outcome (OK, FAILED, DEADLINE_EXCEEDED, etc.)
    pub outcome: CodeExecutionOutcome,
    /// The output of the code execution (stdout for success, error message for failure)
    pub output: &'a str,
}

/// Information about a URL context result.
///
/// Returned by [`InteractionResponse::url_context_results()`] for convenient access
/// to URL context results.
///
/// This is a **view type** that borrows data from the underlying [`InteractionResponse`].
/// It implements [`Serialize`] for logging and debugging purposes, but not `Deserialize`
/// since it's not meant to be constructed directly—use the response helper methods instead.
///
/// # Example
///
/// ```no_run
/// # use genai_client::models::interactions::InteractionResponse;
/// # let response: InteractionResponse = todo!();
/// for result in response.url_context_results() {
///     println!("URL: {}", result.url);
///     if let Some(content) = result.content {
///         println!("Content: {}", content);
///     } else {
///         println!("(fetch failed)");
///     }
/// }
/// ```
#[derive(Debug, Clone, PartialEq, Serialize)]
#[non_exhaustive]
pub struct UrlContextResultInfo<'a> {
    /// The URL that was fetched
    pub url: &'a str,
    /// The fetched content, or `None` if the fetch failed
    pub content: Option<&'a str>,
}

/// Response from creating or retrieving an interaction
#[derive(Clone, Deserialize, Serialize, Debug)]
#[serde(rename_all = "camelCase")]
pub struct InteractionResponse {
    /// Unique identifier for this interaction.
    ///
    /// This field is `None` when the interaction was created with `store=false`,
    /// since non-stored interactions are not assigned an ID by the API.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Model name if a model was used
    #[serde(skip_serializing_if = "Option::is_none")]
    pub model: Option<String>,

    /// Agent name if an agent was used
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent: Option<String>,

    /// The input that was provided (array of content objects)
    #[serde(default)]
    pub input: Vec<InteractionContent>,

    /// The outputs generated by the model/agent (array of content objects)
    #[serde(default)]
    pub outputs: Vec<InteractionContent>,

    /// Current status of the interaction
    pub status: InteractionStatus,

    /// Token usage information
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage: Option<UsageMetadata>,

    /// Tools that were available for this interaction
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tools: Option<Vec<Tool>>,

    /// Grounding metadata when using GoogleSearch tool
    #[serde(skip_serializing_if = "Option::is_none")]
    pub grounding_metadata: Option<GroundingMetadata>,

    /// URL context metadata when using UrlContext tool
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url_context_metadata: Option<UrlContextMetadata>,

    /// Previous interaction ID if this was a follow-up
    #[serde(skip_serializing_if = "Option::is_none")]
    pub previous_interaction_id: Option<String>,
}

impl InteractionResponse {
    // =========================================================================
    // Text Content Helpers
    // =========================================================================

    /// Extract the first text content from outputs
    ///
    /// Returns the first text found in the outputs vector.
    /// Useful for simple queries where you expect a single text response.
    ///
    /// # Example
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(text) = response.text() {
    ///     println!("Response: {}", text);
    /// }
    /// ```
    #[must_use]
    pub fn text(&self) -> Option<&str> {
        self.outputs.iter().find_map(|content| {
            if let InteractionContent::Text { text: Some(t) } = content {
                Some(t.as_str())
            } else {
                None
            }
        })
    }

    /// Extract all text contents concatenated
    ///
    /// Combines all text outputs into a single string.
    /// Useful when the model returns multiple text chunks.
    ///
    /// # Example
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// let full_text = response.all_text();
    /// println!("Complete response: {}", full_text);
    /// ```
    #[must_use]
    pub fn all_text(&self) -> String {
        self.outputs
            .iter()
            .filter_map(|content| {
                if let InteractionContent::Text { text: Some(t) } = content {
                    Some(t.as_str())
                } else {
                    None
                }
            })
            .collect::<Vec<_>>()
            .join("")
    }

    // =========================================================================
    // Function Calling Helpers
    // =========================================================================

    /// Extract function calls from outputs
    ///
    /// Returns a vector of [`FunctionCallInfo`] structs with named fields for
    /// convenient access to function call details.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// for call in response.function_calls() {
    ///     println!("Function: {} with args: {}", call.name, call.args);
    ///     if let Some(id) = call.id {
    ///         // Use call.id when sending results back to the model
    ///         println!("  Call ID: {}", id);
    ///     }
    /// }
    /// ```
    #[must_use]
    pub fn function_calls(&self) -> Vec<FunctionCallInfo<'_>> {
        self.outputs
            .iter()
            .filter_map(|content| {
                if let InteractionContent::FunctionCall {
                    id,
                    name,
                    args,
                    thought_signature,
                } = content
                {
                    Some(FunctionCallInfo {
                        id: id.as_ref().map(|s| s.as_str()),
                        name: name.as_str(),
                        args,
                        thought_signature: thought_signature.as_ref().map(|s| s.as_str()),
                    })
                } else {
                    None
                }
            })
            .collect()
    }

    /// Check if response contains text
    ///
    /// Returns true if any output contains text content.
    #[must_use]
    pub fn has_text(&self) -> bool {
        self.outputs
            .iter()
            .any(|c| matches!(c, InteractionContent::Text { text: Some(_) }))
    }

    /// Check if response contains function calls
    ///
    /// Returns true if any output contains a function call.
    #[must_use]
    pub fn has_function_calls(&self) -> bool {
        self.outputs
            .iter()
            .any(|c| matches!(c, InteractionContent::FunctionCall { .. }))
    }

    /// Check if response contains function results
    ///
    /// Returns true if any output contains a function result.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if response.has_function_results() {
    ///     for result in response.function_results() {
    ///         println!("Function {} returned data", result.name);
    ///     }
    /// }
    /// ```
    #[must_use]
    pub fn has_function_results(&self) -> bool {
        self.outputs
            .iter()
            .any(|c| matches!(c, InteractionContent::FunctionResult { .. }))
    }

    /// Extract function results from outputs
    ///
    /// Returns a vector of [`FunctionResultInfo`] structs with named fields for
    /// convenient access to function result details.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// for result in response.function_results() {
    ///     println!("Function {} (call_id: {}) returned: {}",
    ///         result.name, result.call_id, result.result);
    /// }
    /// ```
    #[must_use]
    pub fn function_results(&self) -> Vec<FunctionResultInfo<'_>> {
        self.outputs
            .iter()
            .filter_map(|content| {
                if let InteractionContent::FunctionResult {
                    name,
                    call_id,
                    result,
                } = content
                {
                    Some(FunctionResultInfo {
                        name: name.as_str(),
                        call_id: call_id.as_str(),
                        result,
                    })
                } else {
                    None
                }
            })
            .collect()
    }

    // =========================================================================
    // Thinking/Reasoning Helpers
    // =========================================================================

    /// Check if response contains thoughts (internal reasoning)
    ///
    /// Returns true if any output contains thought content.
    #[must_use]
    pub fn has_thoughts(&self) -> bool {
        self.outputs
            .iter()
            .any(|c| matches!(c, InteractionContent::Thought { text: Some(_) }))
    }

    /// Get an iterator over all thought content (internal reasoning).
    ///
    /// Returns the text content of each `Thought` variant in the outputs.
    /// Thoughts represent the model's chain-of-thought reasoning when
    /// thinking mode is enabled via `with_thinking_level()`.
    ///
    /// # Example
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// for thought in response.thoughts() {
    ///     println!("Reasoning: {}", thought);
    /// }
    /// ```
    pub fn thoughts(&self) -> impl Iterator<Item = &str> {
        self.outputs.iter().filter_map(|c| match c {
            InteractionContent::Thought { text: Some(t) } => Some(t.as_str()),
            _ => None,
        })
    }

    // =========================================================================
    // Unknown Content Helpers (Evergreen Forward Compatibility)
    // =========================================================================

    /// Check if response contains unknown content types.
    ///
    /// Returns `true` if any output contains an [`InteractionContent::Unknown`] variant.
    /// This indicates the API returned content types that this library version doesn't
    /// recognize.
    ///
    /// # When to Use
    ///
    /// Call this after receiving a response to detect if you might be missing content:
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if response.has_unknown() {
    ///     eprintln!("Warning: Response contains unknown content types");
    ///     for (content_type, data) in response.unknown_content() {
    ///         eprintln!("  - {}: {:?}", content_type, data);
    ///     }
    /// }
    /// ```
    #[must_use]
    pub fn has_unknown(&self) -> bool {
        self.outputs
            .iter()
            .any(|c| matches!(c, InteractionContent::Unknown { .. }))
    }

    /// Get all unknown content as (content_type, data) tuples.
    ///
    /// Returns a vector of references to the type names and JSON data for all
    /// [`InteractionContent::Unknown`] variants in the outputs.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// for (content_type, data) in response.unknown_content() {
    ///     println!("Unknown type '{}': {}", content_type, data);
    /// }
    /// ```
    #[must_use]
    pub fn unknown_content(&self) -> Vec<(&str, &serde_json::Value)> {
        self.outputs
            .iter()
            .filter_map(|content| {
                if let InteractionContent::Unknown { content_type, data } = content {
                    Some((content_type.as_str(), data))
                } else {
                    None
                }
            })
            .collect()
    }

    // =========================================================================
    // Google Search Metadata Helpers
    // =========================================================================

    /// Check if response has grounding metadata from Google Search.
    ///
    /// Returns true if the response was grounded using the GoogleSearch tool.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if response.has_google_search_metadata() {
    ///     println!("Response is grounded with web sources");
    /// }
    /// ```
    #[must_use]
    pub fn has_google_search_metadata(&self) -> bool {
        self.grounding_metadata.is_some()
    }

    /// Get Google Search grounding metadata if present.
    ///
    /// Returns the grounding metadata containing search queries and web sources
    /// when the GoogleSearch tool was used.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(metadata) = response.google_search_metadata() {
    ///     println!("Search queries: {:?}", metadata.web_search_queries);
    ///     for chunk in &metadata.grounding_chunks {
    ///         println!("Source: {} - {}", chunk.web.title, chunk.web.uri);
    ///     }
    /// }
    /// ```
    #[must_use]
    pub fn google_search_metadata(&self) -> Option<&GroundingMetadata> {
        self.grounding_metadata.as_ref()
    }

    // =========================================================================
    // URL Context Metadata Helpers
    // =========================================================================

    /// Check if response has URL context metadata.
    ///
    /// Returns true if the UrlContext tool was used and metadata is available.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if response.has_url_context_metadata() {
    ///     println!("Response includes URL context");
    /// }
    /// ```
    #[must_use]
    pub fn has_url_context_metadata(&self) -> bool {
        self.url_context_metadata.is_some()
    }

    /// Get URL context metadata if present.
    ///
    /// Returns metadata about URLs that were fetched when the UrlContext tool was used,
    /// including retrieval status for each URL.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(metadata) = response.url_context_metadata() {
    ///     for entry in &metadata.url_metadata {
    ///         println!("URL: {} - Status: {:?}", entry.retrieved_url, entry.url_retrieval_status);
    ///     }
    /// }
    /// ```
    #[must_use]
    pub fn url_context_metadata(&self) -> Option<&UrlContextMetadata> {
        self.url_context_metadata.as_ref()
    }

    // =========================================================================
    // Code Execution Tool Helpers
    // =========================================================================

    /// Check if response contains code execution calls
    #[must_use]
    pub fn has_code_execution_calls(&self) -> bool {
        self.outputs
            .iter()
            .any(|c| matches!(c, InteractionContent::CodeExecutionCall { .. }))
    }

    /// Get the first code execution call, if any.
    ///
    /// Convenience method for the common case where you just want to see
    /// the first code the model wants to execute.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(call) = response.code_execution_call() {
    ///     println!("Model wants to run {} code (id: {}):\n{}", call.language, call.id, call.code);
    /// }
    /// ```
    #[must_use]
    pub fn code_execution_call(&self) -> Option<CodeExecutionCallInfo<'_>> {
        self.outputs.iter().find_map(|content| {
            if let InteractionContent::CodeExecutionCall { id, language, code } = content {
                Some(CodeExecutionCallInfo {
                    id: id.as_str(),
                    language: *language,
                    code: code.as_str(),
                })
            } else {
                None
            }
        })
    }

    /// Extract all code execution calls from outputs
    ///
    /// Returns a vector of [`CodeExecutionCallInfo`] structs with named fields for
    /// convenient access to code execution details.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::{InteractionResponse, CodeExecutionLanguage};
    /// # let response: InteractionResponse = todo!();
    /// for call in response.code_execution_calls() {
    ///     match call.language {
    ///         CodeExecutionLanguage::Python => println!("Python (id: {}):\n{}", call.id, call.code),
    ///         _ => println!("Other (id: {}):\n{}", call.id, call.code),
    ///     }
    /// }
    /// ```
    #[must_use]
    pub fn code_execution_calls(&self) -> Vec<CodeExecutionCallInfo<'_>> {
        self.outputs
            .iter()
            .filter_map(|content| {
                if let InteractionContent::CodeExecutionCall { id, language, code } = content {
                    Some(CodeExecutionCallInfo {
                        id: id.as_str(),
                        language: *language,
                        code: code.as_str(),
                    })
                } else {
                    None
                }
            })
            .collect()
    }

    /// Check if response contains code execution results
    #[must_use]
    pub fn has_code_execution_results(&self) -> bool {
        self.outputs
            .iter()
            .any(|c| matches!(c, InteractionContent::CodeExecutionResult { .. }))
    }

    /// Extract code execution results from outputs
    ///
    /// Returns a vector of [`CodeExecutionResultInfo`] structs with named fields for
    /// convenient access to code execution results.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::{InteractionResponse, CodeExecutionOutcome};
    /// # let response: InteractionResponse = todo!();
    /// for result in response.code_execution_results() {
    ///     if result.outcome.is_success() {
    ///         println!("Code output (call_id: {}): {}", result.call_id, result.output);
    ///     } else {
    ///         eprintln!("Code failed ({}): {}", result.outcome, result.output);
    ///     }
    /// }
    /// ```
    #[must_use]
    pub fn code_execution_results(&self) -> Vec<CodeExecutionResultInfo<'_>> {
        self.outputs
            .iter()
            .filter_map(|content| {
                if let InteractionContent::CodeExecutionResult {
                    call_id,
                    outcome,
                    output,
                } = content
                {
                    Some(CodeExecutionResultInfo {
                        call_id: call_id.as_str(),
                        outcome: *outcome,
                        output: output.as_str(),
                    })
                } else {
                    None
                }
            })
            .collect()
    }

    /// Get the first successful code execution output, if any.
    ///
    /// This is a convenience method for the common case where you just want the
    /// output from successful code execution without handling errors.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(output) = response.successful_code_output() {
    ///     println!("Result: {}", output);
    /// }
    /// ```
    #[must_use]
    pub fn successful_code_output(&self) -> Option<&str> {
        self.outputs.iter().find_map(|content| {
            if let InteractionContent::CodeExecutionResult {
                outcome, output, ..
            } = content
            {
                if outcome.is_success() {
                    Some(output.as_str())
                } else {
                    None
                }
            } else {
                None
            }
        })
    }

    // =========================================================================
    // Google Search Output Content Helpers
    // =========================================================================

    /// Check if response contains Google Search calls
    ///
    /// Returns true if the model performed any Google Search queries.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if response.has_google_search_calls() {
    ///     println!("Model searched: {:?}", response.google_search_calls());
    /// }
    /// ```
    #[must_use]
    pub fn has_google_search_calls(&self) -> bool {
        self.outputs
            .iter()
            .any(|c| matches!(c, InteractionContent::GoogleSearchCall { .. }))
    }

    /// Get the first Google Search query, if any.
    ///
    /// Convenience method for the common case where you just want to see
    /// the first search query performed by the model.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(query) = response.google_search_call() {
    ///     println!("Model searched for: {}", query);
    /// }
    /// ```
    #[must_use]
    pub fn google_search_call(&self) -> Option<&str> {
        self.outputs.iter().find_map(|content| {
            if let InteractionContent::GoogleSearchCall { query } = content {
                Some(query.as_str())
            } else {
                None
            }
        })
    }

    /// Extract Google Search calls (queries) from outputs
    ///
    /// Returns a vector of search query strings.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// for query in response.google_search_calls() {
    ///     println!("Searched for: {}", query);
    /// }
    /// ```
    #[must_use]
    pub fn google_search_calls(&self) -> Vec<&str> {
        self.outputs
            .iter()
            .filter_map(|content| {
                if let InteractionContent::GoogleSearchCall { query } = content {
                    Some(query.as_str())
                } else {
                    None
                }
            })
            .collect()
    }

    /// Check if response contains Google Search results
    #[must_use]
    pub fn has_google_search_results(&self) -> bool {
        self.outputs
            .iter()
            .any(|c| matches!(c, InteractionContent::GoogleSearchResult { .. }))
    }

    /// Extract Google Search results from outputs
    ///
    /// Returns a vector of references to the search result JSON data.
    #[must_use]
    pub fn google_search_results(&self) -> Vec<&serde_json::Value> {
        self.outputs
            .iter()
            .filter_map(|content| {
                if let InteractionContent::GoogleSearchResult { results } = content {
                    Some(results)
                } else {
                    None
                }
            })
            .collect()
    }

    // =========================================================================
    // URL Context Output Content Helpers
    // =========================================================================

    /// Check if response contains URL context calls
    ///
    /// Returns true if the model requested any URLs for context.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if response.has_url_context_calls() {
    ///     println!("Model fetched: {:?}", response.url_context_calls());
    /// }
    /// ```
    #[must_use]
    pub fn has_url_context_calls(&self) -> bool {
        self.outputs
            .iter()
            .any(|c| matches!(c, InteractionContent::UrlContextCall { .. }))
    }

    /// Get the first URL context call, if any.
    ///
    /// Convenience method for the common case where you just want to see
    /// the first URL the model requested.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(url) = response.url_context_call() {
    ///     println!("Model fetched: {}", url);
    /// }
    /// ```
    #[must_use]
    pub fn url_context_call(&self) -> Option<&str> {
        self.outputs.iter().find_map(|content| {
            if let InteractionContent::UrlContextCall { url } = content {
                Some(url.as_str())
            } else {
                None
            }
        })
    }

    /// Extract URL context calls (URLs) from outputs
    ///
    /// Returns a vector of URL strings that were requested for fetching.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// for url in response.url_context_calls() {
    ///     println!("Fetched: {}", url);
    /// }
    /// ```
    #[must_use]
    pub fn url_context_calls(&self) -> Vec<&str> {
        self.outputs
            .iter()
            .filter_map(|content| {
                if let InteractionContent::UrlContextCall { url } = content {
                    Some(url.as_str())
                } else {
                    None
                }
            })
            .collect()
    }

    /// Check if response contains URL context results
    #[must_use]
    pub fn has_url_context_results(&self) -> bool {
        self.outputs
            .iter()
            .any(|c| matches!(c, InteractionContent::UrlContextResult { .. }))
    }

    /// Extract URL context results from outputs
    ///
    /// Returns a vector of [`UrlContextResultInfo`] structs with named fields for
    /// convenient access to URL context results.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// for result in response.url_context_results() {
    ///     println!("URL: {}", result.url);
    ///     if let Some(content) = result.content {
    ///         println!("Content: {}", content);
    ///     }
    /// }
    /// ```
    #[must_use]
    pub fn url_context_results(&self) -> Vec<UrlContextResultInfo<'_>> {
        self.outputs
            .iter()
            .filter_map(|content| {
                if let InteractionContent::UrlContextResult { url, content } = content {
                    Some(UrlContextResultInfo {
                        url: url.as_str(),
                        content: content.as_deref(),
                    })
                } else {
                    None
                }
            })
            .collect()
    }

    // =========================================================================
    // Summary and Diagnostics
    // =========================================================================

    /// Get a summary of content types present in outputs.
    ///
    /// Returns a [`ContentSummary`] with counts for each content type.
    /// Useful for debugging, logging, or detecting unexpected content.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// let summary = response.content_summary();
    /// println!("Response has {} text outputs", summary.text_count);
    /// if summary.unknown_count > 0 {
    ///     println!("Warning: {} unknown types: {:?}",
    ///         summary.unknown_count, summary.unknown_types);
    /// }
    /// ```
    #[must_use]
    pub fn content_summary(&self) -> ContentSummary {
        let mut summary = ContentSummary::default();
        let mut unknown_types_set = BTreeSet::new();

        for content in &self.outputs {
            match content {
                InteractionContent::Text { .. } => summary.text_count += 1,
                InteractionContent::Thought { .. } => summary.thought_count += 1,
                InteractionContent::ThoughtSignature { .. } => {
                    // ThoughtSignature typically only appears during streaming,
                    // not in final outputs. Count with thoughts if present.
                    summary.thought_count += 1
                }
                InteractionContent::Image { .. } => summary.image_count += 1,
                InteractionContent::Audio { .. } => summary.audio_count += 1,
                InteractionContent::Video { .. } => summary.video_count += 1,
                InteractionContent::Document { .. } => summary.document_count += 1,
                InteractionContent::FunctionCall { .. } => summary.function_call_count += 1,
                InteractionContent::FunctionResult { .. } => summary.function_result_count += 1,
                InteractionContent::CodeExecutionCall { .. } => {
                    summary.code_execution_call_count += 1
                }
                InteractionContent::CodeExecutionResult { .. } => {
                    summary.code_execution_result_count += 1
                }
                InteractionContent::GoogleSearchCall { .. } => {
                    summary.google_search_call_count += 1
                }
                InteractionContent::GoogleSearchResult { .. } => {
                    summary.google_search_result_count += 1
                }
                InteractionContent::UrlContextCall { .. } => summary.url_context_call_count += 1,
                InteractionContent::UrlContextResult { .. } => {
                    summary.url_context_result_count += 1
                }
                InteractionContent::Unknown { content_type, .. } => {
                    summary.unknown_count += 1;
                    unknown_types_set.insert(content_type.clone());
                }
            }
        }

        // BTreeSet maintains sorted order, so no need to sort
        summary.unknown_types = unknown_types_set.into_iter().collect();
        summary
    }

    // =========================================================================
    // Token Usage Helpers
    // =========================================================================

    /// Get the number of input (prompt) tokens used.
    ///
    /// Returns `None` if usage metadata is not available.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(tokens) = response.input_tokens() {
    ///     println!("Input tokens: {}", tokens);
    /// }
    /// ```
    #[must_use]
    pub fn input_tokens(&self) -> Option<i32> {
        self.usage.as_ref().and_then(|u| u.total_input_tokens)
    }

    /// Get the number of output tokens generated.
    ///
    /// Returns `None` if usage metadata is not available.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(tokens) = response.output_tokens() {
    ///     println!("Output tokens: {}", tokens);
    /// }
    /// ```
    #[must_use]
    pub fn output_tokens(&self) -> Option<i32> {
        self.usage.as_ref().and_then(|u| u.total_output_tokens)
    }

    /// Get the total number of tokens used (input + output).
    ///
    /// Returns `None` if usage metadata is not available.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(tokens) = response.total_tokens() {
    ///     println!("Total tokens: {}", tokens);
    /// }
    /// ```
    #[must_use]
    pub fn total_tokens(&self) -> Option<i32> {
        self.usage.as_ref().and_then(|u| u.total_tokens)
    }

    /// Get the number of reasoning tokens used (for thinking models).
    ///
    /// Reasoning tokens are used when thinking mode is enabled
    /// (e.g., via `with_thinking_level()` on supported models).
    /// Returns `None` if usage metadata is not available or thinking wasn't used.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(tokens) = response.reasoning_tokens() {
    ///     println!("Reasoning tokens: {}", tokens);
    /// }
    /// ```
    #[must_use]
    pub fn reasoning_tokens(&self) -> Option<i32> {
        self.usage.as_ref().and_then(|u| u.total_reasoning_tokens)
    }

    /// Get the number of cached tokens used (from context caching).
    ///
    /// Cached tokens reduce billing costs when reusing context.
    /// Returns `None` if usage metadata is not available or caching wasn't used.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(tokens) = response.cached_tokens() {
    ///     println!("Cached tokens: {} (reduces cost)", tokens);
    /// }
    /// ```
    #[must_use]
    pub fn cached_tokens(&self) -> Option<i32> {
        self.usage.as_ref().and_then(|u| u.total_cached_tokens)
    }

    /// Get the number of tool use tokens consumed.
    ///
    /// Tool use tokens represent overhead from function calling.
    /// Returns `None` if usage metadata is not available or tools weren't used.
    ///
    /// # Example
    ///
    /// ```no_run
    /// # use genai_client::models::interactions::InteractionResponse;
    /// # let response: InteractionResponse = todo!();
    /// if let Some(tokens) = response.tool_use_tokens() {
    ///     println!("Tool use overhead: {} tokens", tokens);
    /// }
    /// ```
    #[must_use]
    pub fn tool_use_tokens(&self) -> Option<i32> {
        self.usage.as_ref().and_then(|u| u.total_tool_use_tokens)
    }
}

/// Summary of content types present in an interaction response.
///
/// Returned by [`InteractionResponse::content_summary`]. Provides a quick overview
/// of what content types are present, including any unknown types.
///
/// # Example
///
/// ```no_run
/// # use genai_client::models::interactions::InteractionResponse;
/// # let response: InteractionResponse = todo!();
/// let summary = response.content_summary();
///
/// // Check for unexpected content
/// if summary.unknown_count > 0 {
///     log::warn!(
///         "Response contains {} unknown content types: {:?}",
///         summary.unknown_count,
///         summary.unknown_types
///     );
/// }
///
/// // Log content breakdown
/// log::debug!(
///     "Content: {} text, {} thoughts, {} function calls",
///     summary.text_count,
///     summary.thought_count,
///     summary.function_call_count
/// );
/// ```
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct ContentSummary {
    /// Number of text content items
    pub text_count: usize,
    /// Number of thought content items
    pub thought_count: usize,
    /// Number of image content items
    pub image_count: usize,
    /// Number of audio content items
    pub audio_count: usize,
    /// Number of video content items
    pub video_count: usize,
    /// Number of document content items (PDF files)
    pub document_count: usize,
    /// Number of function call content items
    pub function_call_count: usize,
    /// Number of function result content items
    pub function_result_count: usize,
    /// Number of code execution call content items
    pub code_execution_call_count: usize,
    /// Number of code execution result content items
    pub code_execution_result_count: usize,
    /// Number of Google Search call content items
    pub google_search_call_count: usize,
    /// Number of Google Search result content items
    pub google_search_result_count: usize,
    /// Number of URL context call content items
    pub url_context_call_count: usize,
    /// Number of URL context result content items
    pub url_context_result_count: usize,
    /// Number of unknown content items
    pub unknown_count: usize,
    /// List of unique unknown type names encountered (sorted alphabetically)
    pub unknown_types: Vec<String>,
}

impl fmt::Display for ContentSummary {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut parts = Vec::new();

        if self.text_count > 0 {
            parts.push(format!("{} text", self.text_count));
        }
        if self.thought_count > 0 {
            parts.push(format!("{} thought", self.thought_count));
        }
        if self.image_count > 0 {
            parts.push(format!("{} image", self.image_count));
        }
        if self.audio_count > 0 {
            parts.push(format!("{} audio", self.audio_count));
        }
        if self.video_count > 0 {
            parts.push(format!("{} video", self.video_count));
        }
        if self.function_call_count > 0 {
            parts.push(format!("{} function_call", self.function_call_count));
        }
        if self.function_result_count > 0 {
            parts.push(format!("{} function_result", self.function_result_count));
        }
        if self.code_execution_call_count > 0 {
            parts.push(format!(
                "{} code_execution_call",
                self.code_execution_call_count
            ));
        }
        if self.code_execution_result_count > 0 {
            parts.push(format!(
                "{} code_execution_result",
                self.code_execution_result_count
            ));
        }
        if self.google_search_call_count > 0 {
            parts.push(format!(
                "{} google_search_call",
                self.google_search_call_count
            ));
        }
        if self.google_search_result_count > 0 {
            parts.push(format!(
                "{} google_search_result",
                self.google_search_result_count
            ));
        }
        if self.url_context_call_count > 0 {
            parts.push(format!("{} url_context_call", self.url_context_call_count));
        }
        if self.url_context_result_count > 0 {
            parts.push(format!(
                "{} url_context_result",
                self.url_context_result_count
            ));
        }
        if self.unknown_count > 0 {
            parts.push(format!(
                "{} unknown ({:?})",
                self.unknown_count, self.unknown_types
            ));
        }

        if parts.is_empty() {
            write!(f, "empty")
        } else {
            write!(f, "{}", parts.join(", "))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn minimal_response(usage: Option<UsageMetadata>) -> InteractionResponse {
        InteractionResponse {
            id: None,
            model: None,
            agent: None,
            input: vec![],
            outputs: vec![],
            status: InteractionStatus::Completed,
            usage,
            tools: None,
            grounding_metadata: None,
            url_context_metadata: None,
            previous_interaction_id: None,
        }
    }

    #[test]
    fn test_token_helpers_with_usage() {
        let response = minimal_response(Some(UsageMetadata {
            total_input_tokens: Some(100),
            total_output_tokens: Some(50),
            total_tokens: Some(150),
            total_cached_tokens: Some(25),
            total_reasoning_tokens: Some(10),
            total_tool_use_tokens: Some(5),
        }));

        assert_eq!(response.input_tokens(), Some(100));
        assert_eq!(response.output_tokens(), Some(50));
        assert_eq!(response.total_tokens(), Some(150));
        assert_eq!(response.cached_tokens(), Some(25));
        assert_eq!(response.reasoning_tokens(), Some(10));
        assert_eq!(response.tool_use_tokens(), Some(5));
    }

    #[test]
    fn test_token_helpers_without_usage() {
        let response = minimal_response(None);

        assert_eq!(response.input_tokens(), None);
        assert_eq!(response.output_tokens(), None);
        assert_eq!(response.total_tokens(), None);
        assert_eq!(response.cached_tokens(), None);
        assert_eq!(response.reasoning_tokens(), None);
        assert_eq!(response.tool_use_tokens(), None);
    }

    #[test]
    fn test_token_helpers_with_partial_usage() {
        // Test case where only some token counts are available
        let response = minimal_response(Some(UsageMetadata {
            total_input_tokens: Some(100),
            total_output_tokens: Some(50),
            total_tokens: Some(150),
            total_cached_tokens: None,
            total_reasoning_tokens: None,
            total_tool_use_tokens: None,
        }));

        assert_eq!(response.input_tokens(), Some(100));
        assert_eq!(response.output_tokens(), Some(50));
        assert_eq!(response.total_tokens(), Some(150));
        assert_eq!(response.cached_tokens(), None);
        assert_eq!(response.reasoning_tokens(), None);
        assert_eq!(response.tool_use_tokens(), None);
    }
}
