use async_trait::async_trait;
use inventory;
use serde_json::Value;
use std::collections::HashMap;
use std::error::Error;

use crate::types::FunctionDeclaration; // Assuming FunctionDeclaration is in crate::types

/// Represents an error that can occur during function execution.
#[derive(Debug)]
pub enum FunctionError {
    ArgumentMismatch(String),
    ExecutionError(Box<dyn Error + Send + Sync>),
}

impl std::fmt::Display for FunctionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ArgumentMismatch(msg) => write!(f, "Argument mismatch: {msg}"),
            Self::ExecutionError(err) => write!(f, "Function execution error: {err}"),
        }
    }
}

impl Error for FunctionError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            Self::ExecutionError(err) => Some(err.as_ref()),
            Self::ArgumentMismatch(_) => None,
        }
    }
}

/// A trait for functions that can be called by the model.
#[async_trait]
pub trait CallableFunction: Send + Sync {
    /// Returns the declaration of the function.
    fn declaration(&self) -> FunctionDeclaration;

    /// Executes the function with the given arguments.
    /// The arguments are provided as a serde_json::Value,
    /// and the function should return a serde_json::Value.
    async fn call(&self, args: Value) -> Result<Value, FunctionError>;
}

/// A factory for creating instances of `CallableFunction`.
/// Instances of this struct will be collected by `inventory`.
pub struct CallableFunctionFactory {
    pub factory_fn: fn() -> Box<dyn CallableFunction>,
}

impl CallableFunctionFactory {
    pub const fn new(factory_fn: fn() -> Box<dyn CallableFunction>) -> Self {
        Self { factory_fn }
    }
}

// Declare that we want to collect `CallableFunctionFactory` instances.
// This needs to be visible to the macros that will submit to it.
// The `pub` keyword here is important.
pub use inventory::submit;

inventory::collect!(CallableFunctionFactory);

/// A registry for callable functions.
pub(crate) struct FunctionRegistry {
    functions: HashMap<String, Box<dyn CallableFunction>>,
}

impl FunctionRegistry {
    /// Creates a new empty function registry.
    fn new() -> Self {
        Self {
            functions: HashMap::new(),
        }
    }

    /// Registers a function directly.
    fn register_raw(&mut self, function: Box<dyn CallableFunction>) {
        let name = function.declaration().name;
        if self.functions.contains_key(&name) {
            eprintln!(
                "Warning: Duplicate function name '{name}' encountered during auto-registration. The last one found will be used."
            );
        }
        self.functions.insert(name, function);
    }

    /// Retrieves a function by its name.
    pub(crate) fn get(&self, name: &str) -> Option<&dyn CallableFunction> {
        self.functions.get(name).map(std::convert::AsRef::as_ref)
    }

    /// Returns an iterator over all registered function declarations.
    pub(crate) fn all_declarations(&self) -> Vec<FunctionDeclaration> {
        self.functions.values().map(|f| f.declaration()).collect()
    }
}

/// Global registry, populated automatically via inventory.
static GLOBAL_FUNCTION_REGISTRY: std::sync::LazyLock<FunctionRegistry> =
    std::sync::LazyLock::new(|| {
        let mut registry = FunctionRegistry::new();

        for factory in inventory::iter::<CallableFunctionFactory> {
            let function = (factory.factory_fn)();
            registry.register_raw(function);
        }

        registry
    });

/// Provides access to the global function registry.
/// This is intended for internal use by the client for automatic function execution.
pub(crate) fn get_global_function_registry() -> &'static FunctionRegistry {
    &GLOBAL_FUNCTION_REGISTRY
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::FunctionDeclaration; // Assuming FunctionDeclaration is in crate::types
    use async_trait::async_trait;
    use serde_json::json;

    // Dummy function for testing purposes.
    // In real usage, this would be generated by the macro.
    struct TestFunctionGlobal;

    #[async_trait]
    impl CallableFunction for TestFunctionGlobal {
        fn declaration(&self) -> FunctionDeclaration {
            FunctionDeclaration {
                name: "test_function_global".to_string(),
                description: "A global test function".to_string(),
                parameters: Some(json!({
                    "type": "object",
                    "properties": {"param": {"type": "string"}}
                })),
                required: vec!["param".to_string()],
            }
        }

        async fn call(&self, args: Value) -> Result<Value, FunctionError> {
            args.get("param").and_then(Value::as_str).map_or_else(
                || {
                    Err(FunctionError::ArgumentMismatch(
                        "Missing param for Global".to_string(),
                    ))
                },
                |p| Ok(json!({ "result": format!("Global says: Hello, {p}") })),
            )
        }
    }

    // Manually create a factory function for the test, similar to what the macro would do.
    fn test_function_global_callable_factory() -> Box<dyn CallableFunction> {
        Box::new(TestFunctionGlobal)
    }

    // Simulate macro-based registration for testing `FunctionRegistry::new()`
    // This needs to be outside the test function to be collected by inventory.
    inventory::submit! {
        CallableFunctionFactory::new(test_function_global_callable_factory)
    }

    #[test]
    fn test_global_registry_population_and_access() {
        let registry = get_global_function_registry(); // Access the global registry
        let retrieved_func = registry.get("test_function_global");
        assert!(
            retrieved_func.is_some(),
            "Function 'test_function_global' should be in the global registry."
        );
        assert_eq!(
            retrieved_func.unwrap().declaration().name,
            "test_function_global"
        );
    }

    #[tokio::test]
    async fn test_call_global_registered_function() {
        let registry = get_global_function_registry();
        let retrieved_func = registry
            .get("test_function_global")
            .expect("Global function not found");

        let args = json!({ "param": "GlobalInventoryWorld" });
        let result = retrieved_func.call(args).await;
        assert!(result.is_ok());
        assert_eq!(
            result.unwrap(),
            json!({ "result": "Global says: Hello, GlobalInventoryWorld" })
        );
    }
}
