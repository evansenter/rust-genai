use thiserror::Error;

// Re-export unified function declaration types from genai_client
pub use genai_client::{FunctionDeclaration, FunctionDeclarationBuilder, FunctionParameters, Tool};

// Re-export Interactions API types for convenient access
pub use genai_client::{
    CodeExecutionOutcome, ContentSummary, CreateInteractionRequest, FunctionCallInfo,
    FunctionResultInfo, GenerationConfig, GroundingChunk, GroundingMetadata, InteractionContent,
    InteractionInput, InteractionResponse, InteractionStatus, StreamChunk, UrlContextMetadata,
    UrlMetadataEntry, UrlRetrievalStatus, UsageMetadata, WebSource,
};

// Interactions API helper functions
//
// ## Export Strategy
//
// We re-export helper functions that users need to **construct** content to send to the API:
// - Multimodal inputs (images, audio, video) - users build these to send
// - Function results - users send these after executing functions
// - Function calls - needed for multi-turn conversations to echo back the model's call
//
// We do NOT re-export helpers for built-in tool outputs (google_search_*, code_execution_*,
// url_context_*) because those are **generated by the model** and users just read them from
// responses via helper methods like `response.google_search_results()`.
// These are still accessible via `rust_genai::interactions_api::*` if needed.
pub mod interactions_api;
pub use interactions_api::{
    audio_data_content, audio_uri_content, build_interaction_input, function_call_content,
    function_call_content_with_signature, function_result_content, image_data_content,
    image_uri_content, text_content, text_input, thought_content, video_data_content,
    video_uri_content,
};

pub mod client;
pub use client::{Client, ClientBuilder};

pub mod request_builder;
pub use request_builder::{DEFAULT_MAX_FUNCTION_CALL_LOOPS, InteractionBuilder};

pub mod function_calling;
// Re-export public types from function_calling module
pub use function_calling::{CallableFunction, FunctionError};

/// Defines errors that can occur when interacting with the `GenAI` API.
///
/// # Example: Handling API Errors
///
/// ```ignore
/// match client.interaction().create().await {
///     Err(GenaiError::Api { status_code: 429, request_id, .. }) => {
///         log::warn!("Rate limited, request_id: {:?}", request_id);
///         // Retry with backoff
///     }
///     Err(GenaiError::Api { status_code, message, request_id }) => {
///         log::error!("API error {}: {} (request: {:?})", status_code, message, request_id);
///     }
///     // ...
/// }
/// ```
#[derive(Debug, Error)]
pub enum GenaiError {
    #[error("HTTP request error: {0}")]
    Http(#[from] reqwest::Error),
    #[error("SSE parsing error: {0}")]
    Parse(String),
    #[error("JSON deserialization error: {0}")]
    Json(#[from] serde_json::Error),
    #[error("UTF-8 decoding error: {0}")]
    Utf8(#[from] std::str::Utf8Error),
    /// API error with structured context for debugging and automated handling.
    ///
    /// Contains the HTTP status code (for retry logic), error message, and
    /// optional request ID (for correlation with Google API logs/support).
    #[error("API error (HTTP {status_code}): {message}")]
    Api {
        /// HTTP status code (e.g., 400, 429, 500)
        status_code: u16,
        /// Error message from the API response body
        message: String,
        /// Request ID from `x-goog-request-id` header, if available
        request_id: Option<String>,
    },
    #[error("Internal client error: {0}")]
    Internal(String),
    #[error("Invalid input: {0}")]
    InvalidInput(String),
}

// Implement conversion from internal error to public error
impl From<genai_client::InternalError> for GenaiError {
    fn from(internal_err: genai_client::InternalError) -> Self {
        match internal_err {
            genai_client::InternalError::Http(e) => Self::Http(e),
            genai_client::InternalError::Parse(s) => Self::Parse(s),
            genai_client::InternalError::Json(e) => Self::Json(e),
            genai_client::InternalError::Utf8(e) => Self::Utf8(e),
            genai_client::InternalError::Api {
                status_code,
                message,
                request_id,
            } => Self::Api {
                status_code,
                message,
                request_id,
            },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*; // This will bring in Client, InteractionResponse, etc.
    use genai_client::InternalError;

    #[test]
    fn test_internal_error_to_genai_error_conversion() {
        // Test Parse variant
        let internal_parse = InternalError::Parse("parse error".to_string());
        let public_parse: GenaiError = internal_parse.into();
        assert!(matches!(public_parse, GenaiError::Parse(s) if s == "parse error"));

        // Test Http variant - we'll skip this test since creating a reqwest::Error is complex
        // and the #[from] attribute is well-tested in the reqwest crate itself
        // If we need to test this in the future, we can use a mock HTTP client

        // Test Json variant
        let invalid_json = "{invalid json";
        let json_error = serde_json::from_str::<serde_json::Value>(invalid_json).unwrap_err();
        let internal_json = InternalError::Json(json_error);
        let public_json: GenaiError = internal_json.into();
        assert!(matches!(public_json, GenaiError::Json(_)));

        // Test Utf8 variant - using a dynamic approach to create invalid UTF-8
        let mut bytes = Vec::new();
        bytes.extend_from_slice(b"valid");
        bytes.push(0xFF); // Add an invalid byte
        let utf8_error = std::str::from_utf8(&bytes).unwrap_err();
        let internal_utf8 = InternalError::Utf8(utf8_error);
        let public_utf8: GenaiError = internal_utf8.into();
        assert!(matches!(public_utf8, GenaiError::Utf8(_)));

        // Test Api variant with structured fields
        let internal_api = InternalError::Api {
            status_code: 429,
            message: "rate limit exceeded".to_string(),
            request_id: Some("req-123".to_string()),
        };
        let public_api: GenaiError = internal_api.into();
        assert!(matches!(
            public_api,
            GenaiError::Api {
                status_code: 429,
                ref message,
                ref request_id,
            } if message == "rate limit exceeded" && request_id == &Some("req-123".to_string())
        ));

        // Test Api variant without request_id
        let internal_api_no_id = InternalError::Api {
            status_code: 500,
            message: "internal error".to_string(),
            request_id: None,
        };
        let public_api_no_id: GenaiError = internal_api_no_id.into();
        assert!(matches!(
            public_api_no_id,
            GenaiError::Api {
                status_code: 500,
                ref message,
                request_id: None,
            } if message == "internal error"
        ));
    }
}
